// Гена работает гендиректором одной очень известной компании. 
// Он придерживается классических взглядов в управлении сотрудниками, поэтому в его компании почти укаждого сотрудника ровно один непосредственный начальник.
// Единственным работником без начальника является он сам.
// Таким образом, если изобразить сотрудников на схеме и провести ребра между сотрудниками и их непосредственными начальниками, 
// получится структура дерева, в корне которого находитсяГена. Все сотрудники занумерованы, а Гена имеет номер 1.
// Сотрудник под номером i придерживается какого-то мнения, выражаемого числом Oi(оно равняется 0 или 1), относительно того, как должна развиваться компания.
// Гена заметил, что когда мнения сотрудника и его непосредственного начальника различны, возникает конфликт, и эффективность всех сотрудников становится крайне низкой.
// Желая привести компанию к успеху, Гена принял волевое решение — ради того, чтобы внутри компании не было конфликтов, он готов уволить одного сотрудника (даже себя!), 
// после чего все сотрудники, оставшиеся без непосредственного начальника, станут главами новых команд (в которые будут входить все их подчиненные).
// Помогите Гене и сообщите, возможно ли уволить кого-то, чтобы в компании не было конфликтов.
// Если да, то дополнительно сообщите максимальный номер сотрудника, которого можно уволить, чтобы в компании не было конфликтов.  

// Формат входных данных
// Первая строка содержит число n >= 3 — количество сотрудников в компании Гены. Каждая из следующих n - 1  строк содержит числа U и V— номера начальника и его подчиненного,
// где U>=1; V<=n;
// Следующая строка содержит числа O1, O2, ..., On = либо 0 либо 1, где Oi — мнение i-го сотрудника. 
// Гарантируется, что иерархия сотрудников представляет из себя дерево, в корне которого находится сотрудник под номером 1.
// Формат выходных данных
// Если невозможно уволить одного из сотрудников, чтобы избежать конфликтов в компании, выведите NO.
// В противном случае выведите YES и максимального по номеру сотрудника, которого стоит уволить.
// Замечание
// В первом примере неважно, кого увольнять. Сотрудник с максимальным номером — 5.
// Во втором примере можно уволить как 1-го, так и 3-го сотрудника. Максимальный подходящий номер — 3.
// Обратите внимание, что в результате увольнения сотрудника под номером 3 сотрудники 6 и 7 останутся без начальника.
// В третьем примере можно показать, что при любом увольнении останутся конфликтующие сотрудники, являющиеся друг другу начальником и подчиненным.
//Пример 1
// Ввод
// 5
// 1 2
// 1 3
// 2 4
// 3 5
// 1 1 1 1 1
// Вывод
// YES
// 5  
//Пример 2
// Ввод
// 7
// 1 2
// 1 3
// 2 4
// 2 5
// 3 6
// 3 7
// 0 0 1 0 0 1 1
// Вывод
// YES
// 3 
//Пример 3
// Ввод
// 5
// 1 2
// 2 3
// 3 4
// 4 5
// 1 0 1 0 1
// Вывод
// NO

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Three {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int count = 0;
        int[][] arr = new int[n - 1][2];
        int[] arrConf = new int[n];
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n - 1; i++) {
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arrConf[i] = sc.nextInt();
        }
        for (int[] el : arr) {
            int first = el[0] - 1;
            int second = el[1] - 1;
            if (arrConf[first] != arrConf[second]) {
                count++;
                map.merge(first, 1, Integer::sum);
                map.merge(second, 1, Integer::sum);
            }
        }
        int maxNum = 0;
        for (Integer el : map.keySet()) {
            if (map.get(el) == count) {
                if (el > maxNum) {
                    maxNum = el;
                }
            }
        }
        System.out.println(count == 0 ? "YES" + "\n" + n : maxNum == 0 ? "NO" : "YES" + "\n" + (maxNum + 1));
    }
}
